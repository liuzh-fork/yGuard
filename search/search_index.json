{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"yGuard yGuard is an open-source Java obfuscation tool. With yGuard , it is easy as pie (\ud83c\udf70) to configure obfuscation through an extensive ant task. This documentation explains how to use the yGuard Java obfuscation and shrinking software. yGuard is brought to you by yWorks GmbH , creator of the family of graph and diagram visualization frameworks yFiles and other excellent products . yGuard comes with a exhaustive set of examples to cover a broad range of use cases. When in doubt, look up the examples for solutions. Table of contents Setup Using Ant Using Maven Using Gradle Task documentation Examples Troubleshooting Compatibility License Problems and Bug Reports If you experience any problems or think you have found a bug feel free to open an issue on our public issue tracker . Please make sure you have read the documentation thoroughly before. We will do our best and try to answer your questions.","title":"yGuard"},{"location":"index.html#yguard","text":"yGuard is an open-source Java obfuscation tool. With yGuard , it is easy as pie (\ud83c\udf70) to configure obfuscation through an extensive ant task. This documentation explains how to use the yGuard Java obfuscation and shrinking software. yGuard is brought to you by yWorks GmbH , creator of the family of graph and diagram visualization frameworks yFiles and other excellent products . yGuard comes with a exhaustive set of examples to cover a broad range of use cases. When in doubt, look up the examples for solutions.","title":"yGuard"},{"location":"index.html#table-of-contents","text":"Setup Using Ant Using Maven Using Gradle Task documentation Examples Troubleshooting Compatibility License","title":"Table of contents"},{"location":"index.html#problems-and-bug-reports","text":"If you experience any problems or think you have found a bug feel free to open an issue on our public issue tracker . Please make sure you have read the documentation thoroughly before. We will do our best and try to answer your questions.","title":"Problems and Bug Reports"},{"location":"compatibility.html","text":"Compatibility Technical requirements yGuard requires JDK 1.7.x or greater and Ant 1.5 or greater installed on your system. It may work with earlier versions of these pieces of software as well, however this has not been tested thoroughly. yGuard 1.3.x and upwards works together with Ant 1.6. Java 14 - Java 17 Compatibility Beginning with version 3.1.0, yGuard supports obfuscation of Java class files that contain record or permittedsubclasses attributes which were introduced with the Java 16 and Java 17 .class file formats. Java 11 - Java 13 Compatibility Beginning with version 2.10, yGuard supports obfuscation of Java class files that contain nesthost or hestmembers attributes which were introduced with the Java 11 .class file format. yGuard does not support obfuscating dynamic instructions which were introduced with the Java 11 .class file format. Please read the notes regarding 3rd party JVM support if you intend to use yGuard with something other than Java. Java 9 / Java 10 Compatibility Beginning with version 2.7, yGuard supports obfuscation of Java class files that contain module information which was introduced with the Java 9 .class file format. yGuard does not change module names, though. yGuard does not support obfuscating multi-release Java archives which were introduced with Java 9. Java 7 / Java 8 Compatibility Beginning with version 2.5, yGuard supports obfuscation of Java class files that contain the invokedynamic instruction, which was introduced with the Java 7 .class file format. JDK 7 does not contain any means of issuing this instruction, with JDK 8 it is being issued when using lambda expressions or default methods. While yGuard does fully support obfuscating invokedynamic instructions and therefore default methods and lambda expressions, shrinking of Java class files that contain this instruction is not supported yet. Compatibility to 3rd party JVM Obfuscating dynamic and invokedynamic instructions is a task that is theoretically infeasible. An obfuscation program cannot determine the type and parameters of such instructions in a generic way. A trade-off solution for this is supporting known MetaFactory objects by their signature. The JRE makes this task quite trivial. yGuard supports the built-in LambdaMetafactory and StringConcatFactory . This trade-off however means yGuard offers only limited support for instruction sets based on invokedynamic or dynamic . In particular, supporting new JVM targets, such as Scala, might require manual work. As we currently do not have the expertise, nor do we have the resources for this project, this is a chore left for the community. Below is a documentation on the design process involved in supporting the LambdaMetafactory . It should serve as a base for anyone deciding to add more support for e.g Scala or Groovy. How LambdaMetafactory is covered To check that JVM compatibility is ensured in new releases, we verified that there are no differences in the class file format in JVM >= 11. This can be checked in the documentation of the class file format . The JRE ships two targets for the invokedynamic and dynamic instruction sets. These are: LambdaMetafactory StringConcatFactory We can recognise these factories in the obfuscation and shrinking steps using their signature. Looking at the documentation tells us that we should cover two signatures for LambdaMetaFactory : java/lang/invoke/LambdaMetafactory#metafactory java/lang/invoke/LambdaMetafactory#altMetafactory yFiles recognises these methods during renaming . In order to obfuscate lambdas, these steps are performed: if an instance of InvokeDynamicCpInfo is found while parsing the constant pool , check its signature if it has a LambdaMetafactory signature handle the special case In the LambdaMetafactoryTest example, this will remap com/yworks/yguard/obf/LambdaMetaFactoryTest$MyInterface; to La/a/a/a/a$_a; . Most instances of lambda invocations will do a remapping on the JRE functional interface . However, this process must be carefully tested with actual Java byte code. Even though StringConcatFactory uses similar code, its semantics is completely different. Implementing such a factory requires in-depth knowledge of the underlying mechanism. Even in the case of the JDK it is not always perfectly clear which case will be mapped by the compiler to which construct.","title":"Compatibility"},{"location":"compatibility.html#compatibility","text":"","title":"Compatibility"},{"location":"compatibility.html#technical-requirements","text":"yGuard requires JDK 1.7.x or greater and Ant 1.5 or greater installed on your system. It may work with earlier versions of these pieces of software as well, however this has not been tested thoroughly. yGuard 1.3.x and upwards works together with Ant 1.6.","title":"Technical requirements"},{"location":"compatibility.html#java-14-java-17-compatibility","text":"Beginning with version 3.1.0, yGuard supports obfuscation of Java class files that contain record or permittedsubclasses attributes which were introduced with the Java 16 and Java 17 .class file formats.","title":"Java 14 - Java 17 Compatibility"},{"location":"compatibility.html#java-11-java-13-compatibility","text":"Beginning with version 2.10, yGuard supports obfuscation of Java class files that contain nesthost or hestmembers attributes which were introduced with the Java 11 .class file format. yGuard does not support obfuscating dynamic instructions which were introduced with the Java 11 .class file format. Please read the notes regarding 3rd party JVM support if you intend to use yGuard with something other than Java.","title":"Java 11 - Java 13 Compatibility"},{"location":"compatibility.html#java-9-java-10-compatibility","text":"Beginning with version 2.7, yGuard supports obfuscation of Java class files that contain module information which was introduced with the Java 9 .class file format. yGuard does not change module names, though. yGuard does not support obfuscating multi-release Java archives which were introduced with Java 9.","title":"Java 9 / Java 10 Compatibility"},{"location":"compatibility.html#java-7-java-8-compatibility","text":"Beginning with version 2.5, yGuard supports obfuscation of Java class files that contain the invokedynamic instruction, which was introduced with the Java 7 .class file format. JDK 7 does not contain any means of issuing this instruction, with JDK 8 it is being issued when using lambda expressions or default methods. While yGuard does fully support obfuscating invokedynamic instructions and therefore default methods and lambda expressions, shrinking of Java class files that contain this instruction is not supported yet.","title":"Java 7 / Java 8 Compatibility"},{"location":"compatibility.html#compatibility-to-3rd-party-jvm","text":"Obfuscating dynamic and invokedynamic instructions is a task that is theoretically infeasible. An obfuscation program cannot determine the type and parameters of such instructions in a generic way. A trade-off solution for this is supporting known MetaFactory objects by their signature. The JRE makes this task quite trivial. yGuard supports the built-in LambdaMetafactory and StringConcatFactory . This trade-off however means yGuard offers only limited support for instruction sets based on invokedynamic or dynamic . In particular, supporting new JVM targets, such as Scala, might require manual work. As we currently do not have the expertise, nor do we have the resources for this project, this is a chore left for the community. Below is a documentation on the design process involved in supporting the LambdaMetafactory . It should serve as a base for anyone deciding to add more support for e.g Scala or Groovy.","title":"Compatibility to 3rd party JVM"},{"location":"compatibility.html#how-lambdametafactory-is-covered","text":"To check that JVM compatibility is ensured in new releases, we verified that there are no differences in the class file format in JVM >= 11. This can be checked in the documentation of the class file format . The JRE ships two targets for the invokedynamic and dynamic instruction sets. These are: LambdaMetafactory StringConcatFactory We can recognise these factories in the obfuscation and shrinking steps using their signature. Looking at the documentation tells us that we should cover two signatures for LambdaMetaFactory : java/lang/invoke/LambdaMetafactory#metafactory java/lang/invoke/LambdaMetafactory#altMetafactory yFiles recognises these methods during renaming . In order to obfuscate lambdas, these steps are performed: if an instance of InvokeDynamicCpInfo is found while parsing the constant pool , check its signature if it has a LambdaMetafactory signature handle the special case In the LambdaMetafactoryTest example, this will remap com/yworks/yguard/obf/LambdaMetaFactoryTest$MyInterface; to La/a/a/a/a$_a; . Most instances of lambda invocations will do a remapping on the JRE functional interface . However, this process must be carefully tested with actual Java byte code. Even though StringConcatFactory uses similar code, its semantics is completely different. Implementing such a factory requires in-depth knowledge of the underlying mechanism. Even in the case of the JDK it is not always perfectly clear which case will be mapped by the compiler to which construct.","title":"How LambdaMetafactory is covered"},{"location":"license.html","text":"License yGuard is licensed under the MIT license. All 3rd party licenses can be found in the 3rdPartyLicenses folder.","title":"License"},{"location":"license.html#license","text":"yGuard is licensed under the MIT license. All 3rd party licenses can be found in the 3rdPartyLicenses folder.","title":"License"},{"location":"setup.html","text":"Setup Depending on your build system, you will use AntRun or Ant directly to run yGuard . Setup using Ant Download the bundle from the Github release page . After downloading and extracting the jar files, place them in a path near to your build script. You may use absolute paths, but our examples expect the jar file to lie in the same directory as your build file. Once extracted, you can use the yguard element like so: <property name=\"version\" value=\"4.0.0\"/> <target name=\"yguard\"> <taskdef name=\"yguard\" classname=\"com.yworks.yguard.YGuardTask\" classpath=\"${projectDir}/yguard-${version}.jar\"/> <yguard> <!-- see the yGuard task documentation for information about the <yguard> element--> </yguard> </target> Setup using Maven You can use yGuard directly from Maven central. Add the yGuard dependency to your POM : <dependency> <groupId>com.yworks</groupId> <artifactId>yguard</artifactId> <version>4.0.0</version> <scope>compile</scope> </dependency> Once declared, you can use the antrun plugin to define the yGuard task like so: <plugin> <artifactId>maven-antrun-plugin</artifactId> <version>1.8</version> <executions> <execution> <phase>package</phase> <goals> <goal>run</goal> </goals> <id>obfuscate</id> <configuration> <tasks> <property name=\"runtime_classpath\" refid=\"maven.runtime.classpath\"/> <taskdef name=\"yguard\" classname=\"com.yworks.yguard.YGuardTask\" classpath=\"${runtime_classpath}\"/> <yguard> <!-- see the yGuard task documentation for information about the <yguard> element--> </yguard> </tasks> </configuration> </execution> </executions> </plugin> Setup using Gradle You can use yGuard directly from Maven central. You can define and use yGuard in your build.gradle : repositories { mavenCentral() } dependencies { compileOnly 'com.yworks:yguard:4.0.0' } task yguard { group 'yGuard' description 'Obfuscates and shrinks the java archive.' doLast { ant.taskdef( name: 'yguard', classname: 'com.yworks.yguard.YGuardTask', classpath: sourceSets.main.compileClasspath.asPath ) ant.yguard { // see the yGuard task documentation for information about the yGuard element } } }","title":"Setup"},{"location":"setup.html#setup","text":"Depending on your build system, you will use AntRun or Ant directly to run yGuard .","title":"Setup"},{"location":"setup.html#setup-using-ant","text":"Download the bundle from the Github release page . After downloading and extracting the jar files, place them in a path near to your build script. You may use absolute paths, but our examples expect the jar file to lie in the same directory as your build file. Once extracted, you can use the yguard element like so: <property name=\"version\" value=\"4.0.0\"/> <target name=\"yguard\"> <taskdef name=\"yguard\" classname=\"com.yworks.yguard.YGuardTask\" classpath=\"${projectDir}/yguard-${version}.jar\"/> <yguard> <!-- see the yGuard task documentation for information about the <yguard> element--> </yguard> </target>","title":"Setup using Ant"},{"location":"setup.html#setup-using-maven","text":"You can use yGuard directly from Maven central. Add the yGuard dependency to your POM : <dependency> <groupId>com.yworks</groupId> <artifactId>yguard</artifactId> <version>4.0.0</version> <scope>compile</scope> </dependency> Once declared, you can use the antrun plugin to define the yGuard task like so: <plugin> <artifactId>maven-antrun-plugin</artifactId> <version>1.8</version> <executions> <execution> <phase>package</phase> <goals> <goal>run</goal> </goals> <id>obfuscate</id> <configuration> <tasks> <property name=\"runtime_classpath\" refid=\"maven.runtime.classpath\"/> <taskdef name=\"yguard\" classname=\"com.yworks.yguard.YGuardTask\" classpath=\"${runtime_classpath}\"/> <yguard> <!-- see the yGuard task documentation for information about the <yguard> element--> </yguard> </tasks> </configuration> </execution> </executions> </plugin>","title":"Setup using Maven"},{"location":"setup.html#setup-using-gradle","text":"You can use yGuard directly from Maven central. You can define and use yGuard in your build.gradle : repositories { mavenCentral() } dependencies { compileOnly 'com.yworks:yguard:4.0.0' } task yguard { group 'yGuard' description 'Obfuscates and shrinks the java archive.' doLast { ant.taskdef( name: 'yguard', classname: 'com.yworks.yguard.YGuardTask', classpath: sourceSets.main.compileClasspath.asPath ) ant.yguard { // see the yGuard task documentation for information about the yGuard element } } }","title":"Setup using Gradle"},{"location":"task_documentation.html","text":"Task documentation Preamble Using the yGuard Ant task, name obfuscation and code shrinking can be seamlessly integrated into your deployment process. The yguard task contains two nested elements that perform the name obfuscation and code shrinking separately: The rename element performs name-obfuscation, renaming all packages, classes, methods and fields according to a selectable name-mapping scheme. Elements can be excluded from the renaming process by annotating them with a certain annotation class in the source code or using a nested keep element. The shrink element removes all code elements that are not reachable from the entrypoints given in the nested keep element. Table of contents yguard element inoutpair element externalclasses element attribute element rename element property element patch element adjust element map element package element class element method element field element shrink element entrypointjar element keep element Controlling obfuscation exclusion with annotations Generating patch JARs Deobfuscating stacktraces DTD used for Ant <yguard> The yguard Element The yguard task is a container element for the rename and shrink task elements as well as configuration elements that are common to rename and shrink . Being a container element only, the yguard task does not perform any actions on its own, but needs a rename and/or shrink child element for name obfuscating and/or code shrinking. Please see the troubleshooting section to learn about common pitfalls when using name obfuscation and shrinking software. Attributes The yguard element has no attributes. Child Elements inoutpair externalclasses attribute rename shrink The inoutpair Element At least one inoutpair element or one non-empty inoutpairs element has to be specified in order to run the yguard tasks. This element specifies the paths to the input and output jar files. inoutpair also supports the usage of directories. This is detected by File.isDirectory . However, in general you do not want to use directories for inoutpairs (advanced use cases). Attributes Attribute Description Required in Specifies an exisiting jar file, which contains the unshrinked and unobfuscated .class files. Yes out Specifies a path to a jar file which will be created and used to put the results of the shrinking and obfuscation process. Yes resources Will only be considered if the yguard element contains a nested shrink element. Determines how the shrinking engine handles all non-.class files. Currently the following three resource policies are supported: copy the default, simply copies all resource files to the output jar. auto copies only those resource files that reside in a directory that still contains one or more .class files after shrinking. none discards all resource files. No, defaults to copy . Child Elements The inoutpair element has no child elements. If multiple jar files need to be obfuscated at once the inoutpairs element can be used alternatively. The inoutpairs Elements Additionally or alternatively to inoutpair elements this element can be specified in order to specify the paths to the input and output jar files. Attributes Attribute Description Required resources Will only be considered if the yguard element contains a nested shrink element. Determines how the shrinking engine handles all non-.class files. Currently the following three resource policies are supported: copy the default, simply copies all resource files to the output jar. auto copies only those resource files that reside in a directory that still contains one or more .class files after shrinking. none discards all resource files. No, defaults to copy . Child Elements patternset optionally a mapper that determines the name mapping between the unobfuscated and obfuscated versions of the jar files. Note that identitymapper and mergemapper are not supported. All matched jar file names need to be mapped to exactly one jar file name that differs from the original jar file. Examples <!-- use all jars in the input-lib-dir directory and obfuscate them to *_obf.jar --> <inoutpairs resources=\"auto\"> <fileset dir=\"${input-lib-dir}\"> <include name=\"myapp*.jar\"/> <exclude name=\"*_obf.jar\"/> </fileset> <mapper type=\"glob\" from=\"*.jar\" to=\"*_obf.jar\"/> </inoutpairs> <!-- the above mapper is the default one so the following snippet does the same --> <inoutpairs resources=\"auto\"> <fileset dir=\"${input-lib-dir}\"> <include name=\"myapp*.jar\"/> <exclude name=\"*_obf.jar\"/> </fileset> </inoutpairs> The externalclasses Element If the jar to be processed by yGuard depends on external classes or libraries, this element can be used to specify classpaths to these entities. These libraries will neither be shrinked nor obfuscated. Use the inoutpair element for this purpose! See the external_library example for an example of when to use this element. In order to achieve a maximum shrinking effect by the shrink task, all external dependencies should be declared in the externalclasses element. Otherwise, all non-private methods of classes that inherit from unresolvable classes will not be shrinked. The elements attributes and child elements can be seen on the Ant documentation page about using path elements . The attribute Element Using the attribute element, you can specify which attributes present in the input classes should be kept in the obfuscated output classes. See the linked_example for an example of when to use this element. Attributes Attribute Description Required name A comma-separated list of attribute names that are to be retained in the shrinked and/or obfuscated class files. Yes Child Elements patternset Example <attribute name=\"SourceFile, LineNumberTable, LocalVariableTable\"> <patternset> <include name=\"com.mycompany.mylibrary.**\"/> </patternset> </attribute> This will retain the attributes named \"SourceFile\" , \"LineNumberTable\" , and \"LocalVariableTable\" effectively enabling debugging information for all classes in the com.mycompany.mylibrary package and subpackages. The shrink Element The shrink task removes all classes, fields and methods that are not reachable from a number of entrypoints given by a nested keep element. See the examples explanation of some common use cases. If your code uses reflection, please read the troubleshooting section for information on this topic. Attributes Attribute Description Required logfile Determines the name of the logfile that is generated during the shrinking process. The logfile contains information about the entrypoints the shrinking engine uses, the removed classes, methods and fields as well as any warnings. If the name ends with a \".gz\", yGuard will automatically create a gzipped version of the file which potentially saves a lot of disc space. No, defaults to yshrinklog.xml createStubs Instead of removing methods completely, this attribute causes the shrink task to insert a method stub that throws a java.lang.InternalError if it is called. This attribute is very useful if the shrinking process causes your application to break and you are uncertain about which additional code entities you have to include in the keep element. Note that classes considered as completely obsolete by the shrinking engine are still removed completely - this attribute only affects obsolete methods of non-obsolete classes. No, defaults to false Child Elements keep entrypointjar The entrypointjar Element The entrypointjar element can be used for convenience if your application uses libraries that are to be shrinked, but the jarfile using these libraries should be left untouched by the shrinking engine. Such a jarfile could be specified as an entrypointjar . Attributes Attribute Description Required name Path to to the jar file to use as entrypointjar. Yes Child Elements The entrypointjar element has no child elements. Example <yguard> <inoutpair in=\"lib-in.jar\" out=\"lib-out.jar\" /> <shrink> <entrypointjar name=\"myApp.jar\"/> </shrink> </yguard> The rename Element The basic idea is, that all elements will be renamed by this task. There are different use cases, where you sometimes want to exclude or simply just have to exclude some elements from name obfuscation, i.e. not rename them but keep in the API as is. See the examples for explanation of some common use cases. If your code uses reflection, please read the troubleshooting section for information on this topic. Excluding elements can be achieved by using the keep element, the mainclass attribute of the rename element and by annotating elements in the source code with the annotation that is specified in the annotationClass attribute of the rename element. Using the nested keep element, you have to specify all classes, methods, fields, and attributes that should be excluded from name obfuscation. Another way is to annotate the elements directly in the source code that should be obfuscated or excluded. You can use the yFiles obfuscation annotation com.yworks.util.annotation.Obfuscation for that or specify your own annotation in the annotationClass attribute of this element. Attribute Description Required mainclass Can be used as a shortcut to specify the mainclass of your application. Both the class name and the main method will be excluded from name obfuscation. Alternatively you may want to consider to exclude the main method only. If your jar contains a Main-Class attribute, the rename task will automatically adjust the value to the obfuscated name. No logfile Determines the name of the logfile that is generated during the renaming process. The logfile contains information about the mappings the name obfuscator generates as well as any warnings. If the name ends with a \".gz\", yGuard will automatically create a gzipped version of the file which potentially saves a lot of disc space. No, defaults to yguardlog.xml conservemanifest A boolean attribute (valid values: true / false ) that determines whether the manifest file of the jars should be left untouched by the renaming engine. If set to false , the manifest will be modified to reflect the new message digests. No, defaults to false . replaceClassNameStrings A boolean attribute (valid values: true / false ) that determines whether the renaming engine should try to replace hardcoded Strings, which are used in conjunction with the MyClass.class construct. If set to false , those Strings will be left untouched and code of the form MyClass.class will break if MyClass gets obfuscated by name. If set to true (the default), yGuard will try to workaround this problem by replacing the hardcoded String with the appropriate obfuscated name. However this will only work if the unobfuscated class file has been generated with the usual compilers ('javac', 'jikes' and 'bjc') or compilers, that produce similar bytecode. This can also have the side-effect of modifying too many Strings, e.g if you have code that looks like System.out.println(\"com.mycompany.MyClass\"); , it might get replaced, if MyClass.class resides in the very same class with something like System.out.println(\"com.A.OoO\"); . It will most likely fail if the class has been previously obfuscated by another obfuscation tool or a different compiler has been used for compilation. Anyway it is always worth it to give it a try, if you want to have 'full obfuscation'. No, defaults to true scramble A boolean attribute (valid values: true / false ) that determines whether the renaming engine should generate pseudorandom name mappings for each invocation. If set to false (the default, for backward compatibility), each obfuscation will used a fixed map that generates names based on the order of the obfuscated elements. If nothing is changed, each obfuscation will generate the same obfuscated names for all elements. If set to true , yGuard generates pseudorandom mappings (using java.util.Random ) that produce different obfuscated names in each build even if the unobfuscated source is unchanged. No, defaults to false annotationClass Specifies the name of the annotation class that can be used to exclude elements by annotating them in the source code. The specified annotation can be any annotation that fits the convention. No, defaults to com.yworks.util.annotation.Obfuscation Child Elements keep property patch adjust map The property Element property elements can be used to give hints to the name obfuscation engine. Depending on the exact version of yGuard, the task may use these hints to control the process of obfuscation. Attributes Attribute Description Required name Specifies a key which may be interpreted by the obfuscation task. Yes value Specifies the corresponding value of the property. Yes Supported properties Name Description Default error-checking Can be used to tell yGuard to bail out if it detects any problems. Currently this property can be set to the following value: pedantic Will make the obfuscation run fail, i.e. the target which uses the rename element will fail, if yGuard detects any problems. false naming-scheme Can be used to tell the renaming engine to use a different naming scheme during the obfuscation. Currently this property can be set to one of the following values: small Will produce very short names, i.e. the resulting jar file will be as small as possible. best Will produce names, that are very likely to be misunderstood by decompilers and disassemblers. Using this naming-scheme it is even impossible on most filesystems to successfully unjar or unzip the resulting jar file (Windows, Standard Unix, Standard Linux, MacOS). However this scheme takes up a lot of space and the resulting jar is likely to become large (typically roughly double the size). mix Is a mixture of both the other two values, which leads to reasonable small but still hard to decompile jar files. small language-conformity Can be used to advise the renaming engine to produce names, that should be decompilable by most decompilers. On the other hand, yGuard can produce class files that should be executable and verifiable by all of todays virtual machines, but produces absolutely nonsense names when decompiled (Ever tried to compile ' int class = false.this super(String$super.init if); ' ?!) Currently this property can be set to one of the following values: compatible Will produce names, that are ok for (most) decompilers, java, jar and manifest files and can be unzipped to most filesystems. legal Will produce names, that are ok for (some) decompilers, java, jar and manifest files. illegal Will produce names, that will crash some tools but usually not the jvm, but JBuilder7 in many occasions for example. legal overload-enabled Determines whether the renaming engine tries to use the same names for methods with different signatures or whether it always generates unique method names. Setting this property to false eases the analysis of stacktraces but reduces the obfuscation effect. true obfuscation-prefix Can be used to instruct the renaming engine to prefix packages, that are fully obfuscated with a given package prefix, e.g. com.mycompany.obf . - digests Can be used to tell yGuard which digest algorithms should be used for the digest generation in the manifest file. Valid values are either none , or a comma-separated list of digest-algorithm identifiers, e.g. SHA-1, MD5 (which is the default). SHA-1, MD5 expose-attributes Can be used to give yGuard a list of attributes yGuard should expose in addition to the standard attributes. By default yGuard removes unneeded attributes like \"Deprecated\" from methods. The value can be a comma separated list of attributes as defined in Section 4.7 of the VM Specification of the .class File Format . E.g. in order to keep the \"Deprecated\" attribute one can add the following property: <property name=\"expose-attributes\" value=\"Deprecated\"/> Note that this affects all classes which will be obfuscated. For a better control of which attributes should be exposed in what classes use the Attribute Element . - Child Elements The property element has no child elements. The keep Element This element is a child of the rename or shrink element. It can be used to specify elements that are excluded from the parent rename or shrink task. The excluded classes, methods and fields are defined using nested package , class , method and field elements. Attributes The keep element provides a number of boolean attributes that determine whether debug information and annotations present in the input class files are to be retained in the output files. The default behavior of the rename and shrink elements for the respective attributes is explained in the table below. Note that a more fine-grained control over which attributes to keep for which class files is possible using the attribute element. Also, the attribute element allows to define attributes to keep for both the rename and the shrink element in a common place. Attribute Description Default ( rename ) Default ( shrink ) sourcefile Determines whether the name of the original source code file should be included in the output class files. remove remove linenumbertable Determines whether the line number table, that contains a mapping from each opcode in the class file to the line number in the original source code file should be included in the output class files. remove remove localvariabletable Determines whether the local variable table, that contains a mapping from each local variable in the class file to the name that has been used in the original source code file should be included in the output class files. remove remove localvariabletypetable Determines whether the local variable type table, that contains a mapping from each local variable in the class file to the name and its generic type signature that has been used in the original source code file should be included in the output class files. remove remove runtimevisibleannotations Determines whether annotations with the retention policy RetentionPolicy.RUNTIME should be included in the output class files. keep 1 keep runtimevisibleparameterannotations Determines whether method paramater annotations with the retention policy RetentionPolicy.RUNTIME should be included in the output class files. keep 1 keep runtimevisibletypeannotations Determines whether type annotations with the retention policy RetentionPolicy.RUNTIME should be included in the output class files. keep 1 keep runtimeinvisibleannotations Determines whether annotations with the retention policy RetentionPolicy.CLASS should be included in the output class files. keep 1 remove runtimeinvisibleparameterannotations Determines whether method paramater annotations with the retention policy RetentionPolicy.CLASS should be included in the output class files. keep 1 remove runtimeinvisibletypeannotations Determines whether type annotations with the retention policy RetentionPolicy.CLASS should be included in the output class files. keep 1 remove 1 rename always keeps annotations irrespective of its runtime*annotations attribute values. The class Element The class element can be used for excluding certain classes and/or their fields and methods from the renaming or shrinking process. If no name , extends or implements attribute is given and the class element contains no nested patternset , a class element matches all class names. The classes , methods and fields attributes tell the shrinking and renaming engines which classes, methods and fields to keep based on their visibility. The following table lists the possible values for all of these attributes and shows which elements will be excluded. A '*' denotes, that elements that have the given visibility will be excluded for the specified attribute value. A '-' denotes that the these elements will not be excluded from the process. Value/Visibility public protected friendly private none - - - - public * - - - protected * * - - friendly * * * - private * * * * Attributes Attribute Description Required name The name of the class to be kept. No classes The visibility of the classes to be kept. No, defaults to none methods The visibility of the methods to be kept. No, defaults to none fields The visibility of the fields to be kept. No, defaults to none extends If no name attribute is given, keeps all classes that equal or extend the class defined by the given fully qualified classname. See serializable_example for an example usage of this attribute. No implements If no name attribute is given, keeps all classes that equal or implement the class defined by the given fully qualified classname. See serializable_example for an example usage of this attribute. No Child elements patternset Explanation There are three possible ways of specifying which classes will be excluded from the shrinking and obfuscation process: 1) One can specify a single java class using the fully qualified name in java syntax with the name attribute. For example: <class name=\"mypackage.MyClass\"/> 2) One can specify multiple java classes using a modified version of a patternset. The patternset's includes and excludes element should use java syntax, but the usual wildcards are allowed. Some examples: <class> <patternset> <include name=\"com.mycompany.**.*Bean\"/> <exclude name=\"com.mycompany.secretpackage.*\"/> <exclude name=\"com.mycompany.myapp.SecretBean\"/> </patternset> </class> 3) This will expose all classes which reside in the package subtree of com.mycompany and whose name ends with Bean except for those, that reside in the com.mycompany.secretpackage package and the single SecretBean in com.mycompany.myapp . <class> <patternset> <include name=\"com.mycompany.myapp.MainClass\"/> <include name=\"org.w3c.sax?.\"/> <exclude name=\"org.w3c.sax?.**.*$$*\"/> </patternset> </class> This will expose the MainClass class and all classes, which reside in packages like org.w3c.sax1 , org.w3c.sax2 , org.w3c.saxb except for inner classes. '$' is used as a separator between outer class names and inner class names. Since Ant uses '$' as an escape character, you have to use two consecutive '$'s ( '$$' ) if you want to pass one as an argument to the task. 4) Finally one can specify classes depending on their visibility, i.e. depending whether they have been declared public , protected , package-private or private (inner classes). This can be achieved by additionally specifying the classes attribute in the class element. ```xml This will keep all class names, that are either `public` or `protected` and which reside in one of the subpackages of `com.mycompany.myapi` (note the abbreviation: the trailing dot behaves like the trailing `'/'` in the usual patternset, i.e. it could be rewritten as `com.mycompany.myapi.**.*`) ```xml <class classes=\"protected\" methods=\"protected\" fields=\"protected\"> <patternset> <include name=\"**.*\"/> </patternset> </class> This example shows the very common use case of excluding a complete public API from the shrinking and obfuscation process. There is an abbreviation for this use case: you can omit the patternset element, since in the case where the classes attribute is specified and there is no patternset child element used, the task will automatically apply this rule. In this example all classes will be exposed, that are either public or protected . Their methods and fields will be exposed as long as they are declared public or protected . If a class is package-private or private (inner classes), neither itself nor its methods or fields will be exposed. The last example shows how to keep the public methods of certain classes only, but neither field names nor the class names themselves. <class classes=\"none\" methods=\"public\" fields=\"none\"> <patternset> <include name=\"com.mycompany.myapi.\"/> </patternset> </class> The method Element Using the method element you can specify methods by signature which should be excluded from shrinking or name obfuscation. Attributes Attribute Description Required name Specifies the method to keep. Use the complete signature using fully qualified class names and the return type! Yes class Specifies the class which contains the method. Use the normal java syntax, i.e. the fully qualified name. This attribute can be omitted, if the patternset element is used as a child element, in which case all classes matching the patternset will be searched and their corresponding methods will be kept. No Child Elements patternset Examples <method class=\"com.mycompany.myapp.MyClass\" name=\"void main(java.lang.String[])\"/> <method class=\"com.mycompany.myapp.MyClass\" name=\"int foo(double[][], java.lang.Object)\"/> <method name=\"void writeObject(java.io.ObjectOutputStream)\"> <patternset> <include name=\"com.mycompany.myapp.data.*\"/> </patternset> </method> <method name=\"void readObject(java.io.ObjectInputStream)\"> <patternset> <include name=\"com.mycompany.myapp.data.*\"/> </patternset> </method> This will keep the main method of the MyClass class and the foo method. Additionally all readObject and writeObject methods (used for serialization) will be kept in all classes of the com.mycompany.myapp.data package. Note that you have to specify the return argument's type, even if it is void and that you have to use the fully qualified name for all classes, even those, that are in the java.lang package . The field Element Using the field element you can specify fields by name which should be excluded from shrinking or name obfuscation. Attributes Attribute Description Required name Specifies the field to keep. Use the name of the field only, do not include its type! Yes class Specifies the class which contains the field. Use the normal java syntax, i.e. the fully qualified name. This attribute can be omitted, if the patternset element is used as a child element, in which case the all classes matching the patternset will be searched and their corresponding fields will be kept. No Child Elements patternset Examples <field class=\"com.mycompany.myapp.MyClass\" name=\"field\"/> <field name=\"serialVersionUID\"> <patternset> <include name=\"com.mycompany.myapp.data.*\"/> </patternset> </field> This will keep the field named field of the MyClass class. Additionally all the serialVersionUID fields (used for serialization) will be kept in all classes of the com.mycompany.myapp.data package. The package Element The package element can be used for excluding certain package's names from the renaming process. It cannot be used for the shrinking process. All packages that are matched be the nested patternset element will not be obfuscated. This has no influence on the class, method, or field names but will only result in the package's name not being obfuscated. Normally, it is not necessary to use this element, instead the class element is used to keep class names (and thus their package names) from being obfuscated. Child Elements patternset Example <package> <patternset> <include name=\"com.mycompany.myapp.*\"/> </patternset> </package> This will keep the names of all packages that are direct descendants of com.mycompany.myapp . This will not influence the names of the classes contained in these packages. The sourcefile Element The sourcefile element allows for a special treatment of the sourceFile attribute by the rename element. Using nested property elements, the mapping of sourceFile attributes in obfuscated class files can be adjusted. Attributes Name Description mapping The value of this property determines the name all sourceFile attributes matched by the sourcefile element are mapped to. Child Elements property patternset Example <sourcefile> <property name=\"mapping\" value=\"y\"/> <patternset> <include name=\"com.mycompany.myapp.**\"/> </patternset> </sourcefile> This will map all of the sourceFile attributes in the packages below com.mycompany.myapp to \"y\" , which is small and generally a nice letter. The linenumbertable Element The linenumbertable element allows for a special treatment of the linenumbertable attribute by the rename element. Using nested property elements, the mapping of linenumbertable attributes in obfuscated class files can be adjusted. Attributes Name Description mapping-scheme Can be used with the following two values: scramble This will use a non-trivial algorithm to scramble the line numbers in the existing file. The algorithm implemented uses a different scrambling scheme for each class. The optional scrambling-salt property can be used to provide an integer value that will be used to \"salt\" the algorithm's random seed for the scrambling. The size of the (uncompressed) .class file will not change using this mapping scheme. squeeze This will use a simple algorithm that virtually puts all of a method's code into the first line of code of the method. It will appear as if each method had been written in a single line of code. The advantage of this scheme is drastically reduced size requirements and thus smaller .class files, while at the same time it will be possible to unambiguously determine the exact method from a stacktrace. scrambling-salt Can be used in conjunction with mapping-scheme to provide an integer value that will be used to \"salt\" the algorithm's random seed for the scrambling. Child Elements property patternset Examples <linenumbertable> <patternset> <include name=\"com.mycompany.myapp.**\"/> </patternset> </linenumbertable> This will keep the line numbers of all the classes in the com.mycompany.myapp packages and subpackages. Note that in order to see the line numbers in stacktraces, the sourcefile attribute has to be retained for those files, too, since otherwise the JDK will display \"Unknown source\" for the stack elements. <linenumbertable> <property name=\"mapping-scheme\" value=\"scramble\"/> <property name=\"scrambling-salt\" value=\"1234\"/> <patternset id=\"CompanyPatternSet\"> <include name=\"com.mycompany.myapp.**\"/> </patternset> </linenumbertable> <sourcefile> <property name=\"mapping\" value=\"y\"/> <patternset refid=\"CompanyPatternSet\"/> </sourcefile> This will keep scrambled line numbers for all classes found in and below the com.mycompany.myapp packages. The scrambling algorithm will use the given \"salt\" value to use a predefined scrambling scheme. In order to see the scrambled line numbers, a sourcefile element is used on the same patternset, which is referenced by its previously declared reference id, to rename the source files to \"y\" . The adjust Element Using the adjust element one can specify resource files whose names and/or contents should be adjusted by the rename engine to reflect the obfuscated class names. Note : This will only adjust files that are part of the inoutpair jars! I.e. the fileset's root directory is the combined root of all jars that are passed to yGuard via the inoutpair elements. yGuard will not modify any of the files on disk, except for the out-jar! Attributes Attribute Description Required replaceContentPolicy Specifies if and how the content of resource files should be adjusted. See replaceContentPolicy for supported values. No, defaults to none replaceContent Deprecated - use replaceContentPolicy instead. Specifies whether or not the contents of resource files should be adjusted. No, defaults to false replaceContentSeparator Specifies which separator is used to replace text in content. Supports . , / , and ./ . No, defaults to / replacePathPolicy Specifies if and how the file names of resource files should be adjusted. See replacePathPolicy for supported values. No, defaults to path replacePath Deprecated - use replacePathPolicy instead. Specifies whether or not the paths to the resource files should be adjusted. No, defaults to true replaceName Deprecated - use replacePathPolicy instead. Specifies whether or not the names of the specified resources should be adjusted. No, defaults to false The replaceContentPolicy Attribute Specifies if and how the content of resource files should be adjusted. Supported values are: none The content of resource files is not adjusted. lenient Text that is recognized as qualifed class or package name is replaced. This policy matches the yGuard 3.x behavior for replaceContent=\"true\" strict Text that is recognized as qualifed class name is replaced. This policy matches the yGuard 2.x behavior for replaceContent=\"true\" The replacePathPolicy Attribute Specifies if and how the file names of resource files should be adjusted. Supported values are: none The paths to and names of resource files are not adjusted. The names of service provider configuration files are not adjusted. This policy matches the yGuard 3.x behavior for replaceName=\"false\" replacePath=\"false\" path The paths to resource files are adjusted, if they match the package name of a renamed package. The names of resource files are not adjusted. The names of service provider configuration files are not adjusted. This policy matches the yGuard 3.x behavior for replaceName=\"false\" replacePath=\"true\" name The paths to resource files are not adjusted. The names of resource files are adjusted, if the path to and the name of the resource file match the qualified name of a renamed class. The names of service provider configuration files are adjusted, if the name of the configuration file matches the qualified name of a renamed class. This policy matches the yGuard 3.x behavior for replaceName=\"true\" replacePath=\"false\" file The paths to and names of resource files are adjusted, if they match the qualified name of a renamed class. The names of service provider configuration files are adjusted, if the name of the configuration file matches the qualified name of a renamed class. This policy matches the yGuard 3.x behavior for replaceName=\"true\" replacePath=\"true\" fileorpath Combines policies file and path . I.e. if the path to and name of a resource file match the qualified name of a renamed class, both path and name are adjusted accordingly. If the path and name do not match the qualified name of a renamed class, but the path matches the package name of a renamed package, the path is adjusted accordingly. If the path does not match the package name of a renamed package, but path fragments match the package name of a renamed package, those path fragments are adjusted accordingly. The names of service provider configuration files are adjusted, if the name of the configuration file matches the qualified name of a renamed class. lenient Tries to adjust as much of the paths to and names of resource and service provider configuration files as possible. For paths to and names of resource files, this policy is the same as fileorpath . The names of service provider configuration files are adjusted, if the name of the configuration file matches the qualified name of a renamed class. If the name does not match the qualified name of a renamed class, but name fragments match the package name of a renamed package, those name fragments are adjusted accordingly. Explanation Suppose yGuard's input set consists of the following files com/mycompany/myproduct/MyClass.class com/mycompany/myproduct/MyClass.properties com/mycompany/myproduct/SomeResource.txt com/mycompany/shared/SharedResource.txt META-INF/services/com.mycompany.myproduct.MyClass META-INF/services/com.mycompany.shared.SharedService and rename changes the name of class com.mycompany.myproduct.MyClass to A.A.A.A . In this case, the individual replacePathPolicy polices will result in the following path and name adjustments: path A/A/A/MyClass.properties A/A/A/SomeResource.txt A/A/shared/SharedResource.txt META-INF/services/com.mycompany.myproduct.MyClass META-INF/services/com.mycompany.shared.SharedService The path com/mycompany/shared does not match any package name, but its path fragments com/mycompany match the package name com.mycompany and thus are changed. The two service provider configuration files are not adjusted. name com/mycompany/myproduct/A.properties com/mycompany/myproduct/SomeResource.txt com/mycompany/shared/SharedResource.txt META-INF/services/A.A.A.A META-INF/services/com.mycompany.shared.SharedService The path to and name of the second and third resource files do not match any qualified class name in the code base and thus are not changed. The name com.mycompany.shared.SharedService does not match any qualified class name and thus is not changed. file A/A/A/A.properties com/mycompany/myproduct/SomeResource.txt com/mycompany/shared/SharedResource.txt META-INF/services/A.A.A.A META-INF/services/com.mycompany.shared.SharedService The path to and name of the second and third resource files do not match any qualified class name in the code base and thus are not changed. The name com.mycompany.shared.SharedService does not match any qualified class name and thus is not changed. fileorpath A/A/A/A.properties A/A/A/SomeResource.txt A/A/shared/SharedResource.txt META-INF/services/A.A.A.A META-INF/services/com.mycompany.shared.SharedService The path com/mycompany/shared does not match any package name, but its path fragments com/mycompany match the package name com.mycompany and thus are changed. The name com.mycompany.shared.SharedService does not match any qualified class name and thus is not changed. lenient A/A/A/A.properties A/A/A/SomeResource.txt A/A/shared/SharedResource.txt META-INF/services/A.A.A.A META-INF/services/A.A.shared.SharedService The path com/mycompany/shared does not match any package name, but its path fragments com/mycompany match the package name com.mycompany and thus are changed. The name com.mycompany.shared.SharedService does not match any qualified class name, but its name fragments com.mycompany match the package name com.mycompany and thus are changed. Child Elements The adjust element can be used just like the standard Ant ZipFileSet element. Examples <!-- adjust the names of all java property files in the jars --> <adjust replacePathPolicy=\"file\"> <include name=\"**/*.properties\"/> </adjust> <!-- adjust the classnames specified within a single XML file in the jar --> <adjust file=\"plugins.xml\" replaceContentPolicy=\"strict\" replaceContentSeparator=\".\"/> <!-- suppress the adjustment of the resource path com/mycompany/myapp/resource in the jar. --> <!-- the package com.mycompany.myapp still gets obfuscated. --> <adjust replacePathPolicy=\"none\"> <include name=\"com/mycompany/myapp/resource/*\"/> </adjust> The map Element The map element is an immediate optional child of the rename element . It can be used to specify the mapping for the renaming process directly. This is an advanced topic. Child Elements package class method field All of these elements use the name attribute to specify the specific element. The method and field elements need the class attribute in order to function properly. Neither wildcards nor nested patternset elements are allowed. Use the map attribute to specify the new name (subpackage, classname, methodname and fieldname respectively). Examples <map> <package name=\"com\" map=\"etc\"/> <package name=\"com.mycompany\" map=\"nocompany\"/> <package name=\"com.mycompany.myapp\" map=\"asdf\"/> <class name=\"com.mycompany.myapp.MainApp\" map=\"foo\"/> <method class=\"com.mycompany.myapp.MainApp\" name=\"void main(java.lang.String[])\" map=\"bar\"/> <field class=\"com.mycompany.myapp.MainApp\" name=\"field\" map=\"a\"/> </map> In this example the package structure com.mycompany.myapp will be obfuscated to etc.nocompany.asdf . The MainApp class will be called foo and its main method will be remapped to bar (and can therefor not be executed from commandline anymore). The field called field will be renamed to a . Controlling obfuscation exclusion with annotations In order to exclude certain elements from obfuscation, it is possible to use annotations in the source code instead of listing those elements in the keep element . Any annotation class can be used for this, but it must be specified in the annotationClass attribute of the rename element and follow the convention as explained below to work. yGuard contains such an annotation in the distribution package ready for use. The annotation class is com.yworks.util.annotation.Obfuscation and can be found in the yGuard distribution in ObfuscationAnnotation.jar . Feel free add this attribute definition to your own codebase and possibly adjust the package name to your needs. Here is the source code for it: Obfuscation.java package com.yworks.util.annotation; public @interface Obfuscation { boolean exclude() default true; boolean applyToMembers() default true; } This class is also the default annotation yGuard is looking for when obfuscating. By default the Obfuscation annotation is inherited using the @Inherited trait. If this behaviour is undesirable, consider creating a custom obfuscation annotation. The convention for annotation classes that yGuard understands as obfuscation controlling annotations requires two attributes: Attribute Description Default value exclude Specifies whether the annotated element should be excluded from the obfuscation. Note, that when retaining a class, the hierarchy of that class, i.e. the chain of outer class names and the package name, is also retained. true applyToMembers Specifies whether the child elements of the annotated element, if not otherwise specified, should be excluded from the obfuscation. For example, when annotating a class with exclude = true and this attribute set to true , inner classes, fields and methods of this class will be excluded from obfuscation. Annotating a child element of an element that has this attribute set to true will override the parents annotation configuration. true Generating Patch JARs The true power of the map element lies in its use together with the patch element, which itself is a child element of the rename top level element. Attributes The patch element has no attributes. Child Elements class Examples Using the patch element one can generate jars, that can be used to serve as patches for versions of an application that have already been deployed in obfuscated form. During the main obfuscation run, yGuard produces an xml-logfile, in which the mapping between the unobfuscated and obfuscated names is contained. The patch element is used to declare a set of classes, that need to be patched. During the obfuscation, yGuard will include those files in the obfuscated jars only, that are declared inside this element. <patch> <class name=\"com.mycompany.myapp.MainClass\"/> <class> <patternset> <include name=\"com.mycompany.myapp.bugs.*\"/> </patternset> </class> </patch> <map logfile=\"yguardlog.xml\"/> This will only include the MainClass class and all classes that belong to the bugs package in a patch jar. In order to work with the previously delivered obfuscated version, it is important to use the map element to specify the mapping of the elements from the previous run. This can most conveniently be achieved by specifying the log file from the corresponding run in the map element's logfile attribute. Deobfuscating stacktraces yGuard provides a simple tool that makes it easy for the obfuscating party to deobfuscate stacktraces which have been obfuscated using yGuard. During the obfuscation yGuard produces an xml logfile which can automatically be gzipped for convenient storage. You should always keep those logfiles in order to be able to deobfuscate fully qualified classnames or methods or fields for debugging purposes e.g. In order to run the yGuard deobfuscation tool do the following: Console> java -jar yguard.jar mylogfile.xml A tiny GUI will popup that will enable you to easily deobfuscate stacktraces and fully qualified classnames as well as provide a convenient way to browse the mapping generated by yGuard. In the main window a tree view displays the package, class, and classmember hierarchy using the unobfuscated names. For each entry that has been obfuscated (classes, packages, methods, and fields that have not been obfuscated at all may not always be shown in the tree) the corresponding mapped/obfuscated name is displayed. The two buttons at the top of the window allow to change the sorting of the items in the tree structure, so that they are either sorted according to their names before or after the obfuscation. Items will always be sorted by type first: packages, classes, innerclasses, methods, and fields. Small icons provide a convenient way to quickly find the corresponding items. The lower part of the window contains an editable text area that can be used to enter text or paste stacktraces in. Pressing the button at the bottom of the window labelled \"Deobfuscate\" will trigger the deobfuscation of the contents in the text area. The tool will try to identify fully qualified class names (separated by dots) and use the mapping information to reconstruct the original names. If the tool identifies a stack trace element, it will try to deobfuscate scrambled line numbers, too, if they have been scrambled during the obfuscation process. DTD used for Ant <yguard> The obfuscation and shrinking process can be completely configured inside your Ant script. The yguard task and nested elements should be used according to the following DTD. Note that this is for information purposes only, i.e. you do not have to include the following lines anywhere. This DTD should just provide a quick overview of the yGuard syntax. Due to restrictions of the DTD specification, the given DTD does not describe all available yGuard options. Please browse through the documentation above for complete documentation of the yGuard Ant task elements. <!ELEMENT yguard (inoutpair+,externalclasses?,attribute*,(shrink|rename)+)> <!ELEMENT inoutpair EMPTY> <!ATTLIST inoutpair in CDATA #REQUIRED out CDATA #REQUIRED resources CDATA #IMPLIED> <!-- NOTE: the resources attribute only has an effect if a shrink element is present inside the yguard element. --> <!ELEMENT externalclasses ANY> <!-- the externalclasses element is used just like Ant's classpath element. See the Ant documentation for further details--> <!ELEMENT attribute (patternset)*> name CDATA #REQUIRED> <!ELEMENT shrink (entrypointjar*,keep?)> <!ATTLIST shrink logfile CDATA #IMPLIED createStubs CDATA #IMPLIED> <!ELEMENT entrypointjar> <!ATTLIST entrypointjar name CDATA #REQUIRED> <!ELEMENT rename (property*,patch?,adjust*,map?,keep?)> <!ATTLIST rename mainclass CDATA #IMPLIED logfile CDATA #IMPLIED conservemanifest CDATA #IMPLIED replaceClassNameStrings CDATA #IMPLIED> <!ELEMENT property EMPTY> <!ATTLIST property name CDATA #REQUIRED value CDATA #REQUIRED> <!ELEMENT patch (class)*> <!ELEMENT adjust (#PCDATA)> <!ATTLIST adjust replaceName CDATA #REQUIRED replaceContent CDATA #REQUIRED replacePath CDATA #REQUIRED> <!ELEMENT map (class|method|field|package)*> <!ELEMENT package (patternset)*> <!ATTLIST package name CDATA #REQUIRED map CDATA #REQUIRED> <!-- NOTE: the map attribute is only supported if the <package> element is nested inside a <map> element, whereas the patternset is only supported inside the <keep>/<expose> sections. --> <!ELEMENT keep (package|class|method|field|sourcefile|linenumbertable)*> <!-- NOTE: the nested <package>,<sourcefile>,<linenumbertable> and <attribute> sections are only supported in the <rename> element. --> <!ATTLIST keep linenumbertable CDATA #IMPLIED localvariabletable CDATA #IMPLIED localvariabletypetable CDATA #IMPLIED runtimeinvisibleannotations CDATA #IMPLIED runtimeinvisibletypeannotations CDATA #IMPLIED runtimevisibleannotations CDATA #IMPLIED runtimevisibletypeannotations CDATA #IMPLIED sourcefile CDATA #IMPLIED> <!ELEMENT class (patternset)*> <!ATTLIST class classes CDATA #IMPLIED fields CDATA #IMPLIED map CDATA #IMPLIED methods CDATA #IMPLIED name CDATA #IMPLIED> <!-- NOTE: the map attribute is only supported if the <class> element is nested inside an <rename> element. --> <!ELEMENT method (patternset)*> <!ATTLIST method class CDATA #IMPLIED map CDATA #IMPLIED name CDATA #IMPLIED> <!-- NOTE: the map attribute is only supported if the <method> element is nested inside an <rename> element. --> <!ELEMENT field (patternset)*> <!ATTLIST field class CDATA #IMPLIED map CDATA #IMPLIED name CDATA #IMPLIED> <!-- NOTE: the field attribute is only supported if the <method> element is nested inside an <rename> element. --> Attention users of IDEs that \"support\" the creation of Ant files (e.g. IDEA's IntelliJ): Your IDE may indicate some errors inside your ANT file when you use yGuard specific elements. This is because the IDE does not know about the DTD used by yGuard. However this is not a real problem, since the Ant file should nevertheless work as expected.","title":"Task documentation"},{"location":"task_documentation.html#task-documentation","text":"","title":"Task documentation"},{"location":"task_documentation.html#preamble","text":"Using the yGuard Ant task, name obfuscation and code shrinking can be seamlessly integrated into your deployment process. The yguard task contains two nested elements that perform the name obfuscation and code shrinking separately: The rename element performs name-obfuscation, renaming all packages, classes, methods and fields according to a selectable name-mapping scheme. Elements can be excluded from the renaming process by annotating them with a certain annotation class in the source code or using a nested keep element. The shrink element removes all code elements that are not reachable from the entrypoints given in the nested keep element.","title":"Preamble"},{"location":"task_documentation.html#table-of-contents","text":"yguard element inoutpair element externalclasses element attribute element rename element property element patch element adjust element map element package element class element method element field element shrink element entrypointjar element keep element Controlling obfuscation exclusion with annotations Generating patch JARs Deobfuscating stacktraces DTD used for Ant <yguard>","title":"Table of contents"},{"location":"task_documentation.html#the-yguard-element","text":"The yguard task is a container element for the rename and shrink task elements as well as configuration elements that are common to rename and shrink . Being a container element only, the yguard task does not perform any actions on its own, but needs a rename and/or shrink child element for name obfuscating and/or code shrinking. Please see the troubleshooting section to learn about common pitfalls when using name obfuscation and shrinking software.","title":"The yguard Element"},{"location":"task_documentation.html#attributes","text":"The yguard element has no attributes.","title":"Attributes"},{"location":"task_documentation.html#child-elements","text":"inoutpair externalclasses attribute rename shrink","title":"Child Elements"},{"location":"task_documentation.html#the-inoutpair-element","text":"At least one inoutpair element or one non-empty inoutpairs element has to be specified in order to run the yguard tasks. This element specifies the paths to the input and output jar files. inoutpair also supports the usage of directories. This is detected by File.isDirectory . However, in general you do not want to use directories for inoutpairs (advanced use cases).","title":"The inoutpair Element"},{"location":"task_documentation.html#attributes_1","text":"Attribute Description Required in Specifies an exisiting jar file, which contains the unshrinked and unobfuscated .class files. Yes out Specifies a path to a jar file which will be created and used to put the results of the shrinking and obfuscation process. Yes resources Will only be considered if the yguard element contains a nested shrink element. Determines how the shrinking engine handles all non-.class files. Currently the following three resource policies are supported: copy the default, simply copies all resource files to the output jar. auto copies only those resource files that reside in a directory that still contains one or more .class files after shrinking. none discards all resource files. No, defaults to copy .","title":"Attributes"},{"location":"task_documentation.html#child-elements_1","text":"The inoutpair element has no child elements. If multiple jar files need to be obfuscated at once the inoutpairs element can be used alternatively.","title":"Child Elements"},{"location":"task_documentation.html#the-inoutpairs-elements","text":"Additionally or alternatively to inoutpair elements this element can be specified in order to specify the paths to the input and output jar files.","title":"The inoutpairs Elements"},{"location":"task_documentation.html#attributes_2","text":"Attribute Description Required resources Will only be considered if the yguard element contains a nested shrink element. Determines how the shrinking engine handles all non-.class files. Currently the following three resource policies are supported: copy the default, simply copies all resource files to the output jar. auto copies only those resource files that reside in a directory that still contains one or more .class files after shrinking. none discards all resource files. No, defaults to copy .","title":"Attributes"},{"location":"task_documentation.html#child-elements_2","text":"patternset optionally a mapper that determines the name mapping between the unobfuscated and obfuscated versions of the jar files. Note that identitymapper and mergemapper are not supported. All matched jar file names need to be mapped to exactly one jar file name that differs from the original jar file.","title":"Child Elements"},{"location":"task_documentation.html#examples","text":"<!-- use all jars in the input-lib-dir directory and obfuscate them to *_obf.jar --> <inoutpairs resources=\"auto\"> <fileset dir=\"${input-lib-dir}\"> <include name=\"myapp*.jar\"/> <exclude name=\"*_obf.jar\"/> </fileset> <mapper type=\"glob\" from=\"*.jar\" to=\"*_obf.jar\"/> </inoutpairs> <!-- the above mapper is the default one so the following snippet does the same --> <inoutpairs resources=\"auto\"> <fileset dir=\"${input-lib-dir}\"> <include name=\"myapp*.jar\"/> <exclude name=\"*_obf.jar\"/> </fileset> </inoutpairs>","title":"Examples"},{"location":"task_documentation.html#the-externalclasses-element","text":"If the jar to be processed by yGuard depends on external classes or libraries, this element can be used to specify classpaths to these entities. These libraries will neither be shrinked nor obfuscated. Use the inoutpair element for this purpose! See the external_library example for an example of when to use this element. In order to achieve a maximum shrinking effect by the shrink task, all external dependencies should be declared in the externalclasses element. Otherwise, all non-private methods of classes that inherit from unresolvable classes will not be shrinked. The elements attributes and child elements can be seen on the Ant documentation page about using path elements .","title":"The externalclasses Element"},{"location":"task_documentation.html#the-attribute-element","text":"Using the attribute element, you can specify which attributes present in the input classes should be kept in the obfuscated output classes. See the linked_example for an example of when to use this element.","title":"The attribute Element"},{"location":"task_documentation.html#attributes_3","text":"Attribute Description Required name A comma-separated list of attribute names that are to be retained in the shrinked and/or obfuscated class files. Yes","title":"Attributes"},{"location":"task_documentation.html#child-elements_3","text":"patternset","title":"Child Elements"},{"location":"task_documentation.html#example","text":"<attribute name=\"SourceFile, LineNumberTable, LocalVariableTable\"> <patternset> <include name=\"com.mycompany.mylibrary.**\"/> </patternset> </attribute> This will retain the attributes named \"SourceFile\" , \"LineNumberTable\" , and \"LocalVariableTable\" effectively enabling debugging information for all classes in the com.mycompany.mylibrary package and subpackages.","title":"Example"},{"location":"task_documentation.html#the-shrink-element","text":"The shrink task removes all classes, fields and methods that are not reachable from a number of entrypoints given by a nested keep element. See the examples explanation of some common use cases. If your code uses reflection, please read the troubleshooting section for information on this topic.","title":"The shrink Element"},{"location":"task_documentation.html#attributes_4","text":"Attribute Description Required logfile Determines the name of the logfile that is generated during the shrinking process. The logfile contains information about the entrypoints the shrinking engine uses, the removed classes, methods and fields as well as any warnings. If the name ends with a \".gz\", yGuard will automatically create a gzipped version of the file which potentially saves a lot of disc space. No, defaults to yshrinklog.xml createStubs Instead of removing methods completely, this attribute causes the shrink task to insert a method stub that throws a java.lang.InternalError if it is called. This attribute is very useful if the shrinking process causes your application to break and you are uncertain about which additional code entities you have to include in the keep element. Note that classes considered as completely obsolete by the shrinking engine are still removed completely - this attribute only affects obsolete methods of non-obsolete classes. No, defaults to false","title":"Attributes"},{"location":"task_documentation.html#child-elements_4","text":"keep entrypointjar","title":"Child Elements"},{"location":"task_documentation.html#the-entrypointjar-element","text":"The entrypointjar element can be used for convenience if your application uses libraries that are to be shrinked, but the jarfile using these libraries should be left untouched by the shrinking engine. Such a jarfile could be specified as an entrypointjar .","title":"The entrypointjar Element"},{"location":"task_documentation.html#attributes_5","text":"Attribute Description Required name Path to to the jar file to use as entrypointjar. Yes","title":"Attributes"},{"location":"task_documentation.html#child-elements_5","text":"The entrypointjar element has no child elements.","title":"Child Elements"},{"location":"task_documentation.html#example_1","text":"<yguard> <inoutpair in=\"lib-in.jar\" out=\"lib-out.jar\" /> <shrink> <entrypointjar name=\"myApp.jar\"/> </shrink> </yguard>","title":"Example"},{"location":"task_documentation.html#the-rename-element","text":"The basic idea is, that all elements will be renamed by this task. There are different use cases, where you sometimes want to exclude or simply just have to exclude some elements from name obfuscation, i.e. not rename them but keep in the API as is. See the examples for explanation of some common use cases. If your code uses reflection, please read the troubleshooting section for information on this topic. Excluding elements can be achieved by using the keep element, the mainclass attribute of the rename element and by annotating elements in the source code with the annotation that is specified in the annotationClass attribute of the rename element. Using the nested keep element, you have to specify all classes, methods, fields, and attributes that should be excluded from name obfuscation. Another way is to annotate the elements directly in the source code that should be obfuscated or excluded. You can use the yFiles obfuscation annotation com.yworks.util.annotation.Obfuscation for that or specify your own annotation in the annotationClass attribute of this element. Attribute Description Required mainclass Can be used as a shortcut to specify the mainclass of your application. Both the class name and the main method will be excluded from name obfuscation. Alternatively you may want to consider to exclude the main method only. If your jar contains a Main-Class attribute, the rename task will automatically adjust the value to the obfuscated name. No logfile Determines the name of the logfile that is generated during the renaming process. The logfile contains information about the mappings the name obfuscator generates as well as any warnings. If the name ends with a \".gz\", yGuard will automatically create a gzipped version of the file which potentially saves a lot of disc space. No, defaults to yguardlog.xml conservemanifest A boolean attribute (valid values: true / false ) that determines whether the manifest file of the jars should be left untouched by the renaming engine. If set to false , the manifest will be modified to reflect the new message digests. No, defaults to false . replaceClassNameStrings A boolean attribute (valid values: true / false ) that determines whether the renaming engine should try to replace hardcoded Strings, which are used in conjunction with the MyClass.class construct. If set to false , those Strings will be left untouched and code of the form MyClass.class will break if MyClass gets obfuscated by name. If set to true (the default), yGuard will try to workaround this problem by replacing the hardcoded String with the appropriate obfuscated name. However this will only work if the unobfuscated class file has been generated with the usual compilers ('javac', 'jikes' and 'bjc') or compilers, that produce similar bytecode. This can also have the side-effect of modifying too many Strings, e.g if you have code that looks like System.out.println(\"com.mycompany.MyClass\"); , it might get replaced, if MyClass.class resides in the very same class with something like System.out.println(\"com.A.OoO\"); . It will most likely fail if the class has been previously obfuscated by another obfuscation tool or a different compiler has been used for compilation. Anyway it is always worth it to give it a try, if you want to have 'full obfuscation'. No, defaults to true scramble A boolean attribute (valid values: true / false ) that determines whether the renaming engine should generate pseudorandom name mappings for each invocation. If set to false (the default, for backward compatibility), each obfuscation will used a fixed map that generates names based on the order of the obfuscated elements. If nothing is changed, each obfuscation will generate the same obfuscated names for all elements. If set to true , yGuard generates pseudorandom mappings (using java.util.Random ) that produce different obfuscated names in each build even if the unobfuscated source is unchanged. No, defaults to false annotationClass Specifies the name of the annotation class that can be used to exclude elements by annotating them in the source code. The specified annotation can be any annotation that fits the convention. No, defaults to com.yworks.util.annotation.Obfuscation","title":"The rename Element"},{"location":"task_documentation.html#child-elements_6","text":"keep property patch adjust map","title":"Child Elements"},{"location":"task_documentation.html#the-property-element","text":"property elements can be used to give hints to the name obfuscation engine. Depending on the exact version of yGuard, the task may use these hints to control the process of obfuscation.","title":"The property Element"},{"location":"task_documentation.html#attributes_6","text":"Attribute Description Required name Specifies a key which may be interpreted by the obfuscation task. Yes value Specifies the corresponding value of the property. Yes","title":"Attributes"},{"location":"task_documentation.html#supported-properties","text":"Name Description Default error-checking Can be used to tell yGuard to bail out if it detects any problems. Currently this property can be set to the following value: pedantic Will make the obfuscation run fail, i.e. the target which uses the rename element will fail, if yGuard detects any problems. false naming-scheme Can be used to tell the renaming engine to use a different naming scheme during the obfuscation. Currently this property can be set to one of the following values: small Will produce very short names, i.e. the resulting jar file will be as small as possible. best Will produce names, that are very likely to be misunderstood by decompilers and disassemblers. Using this naming-scheme it is even impossible on most filesystems to successfully unjar or unzip the resulting jar file (Windows, Standard Unix, Standard Linux, MacOS). However this scheme takes up a lot of space and the resulting jar is likely to become large (typically roughly double the size). mix Is a mixture of both the other two values, which leads to reasonable small but still hard to decompile jar files. small language-conformity Can be used to advise the renaming engine to produce names, that should be decompilable by most decompilers. On the other hand, yGuard can produce class files that should be executable and verifiable by all of todays virtual machines, but produces absolutely nonsense names when decompiled (Ever tried to compile ' int class = false.this super(String$super.init if); ' ?!) Currently this property can be set to one of the following values: compatible Will produce names, that are ok for (most) decompilers, java, jar and manifest files and can be unzipped to most filesystems. legal Will produce names, that are ok for (some) decompilers, java, jar and manifest files. illegal Will produce names, that will crash some tools but usually not the jvm, but JBuilder7 in many occasions for example. legal overload-enabled Determines whether the renaming engine tries to use the same names for methods with different signatures or whether it always generates unique method names. Setting this property to false eases the analysis of stacktraces but reduces the obfuscation effect. true obfuscation-prefix Can be used to instruct the renaming engine to prefix packages, that are fully obfuscated with a given package prefix, e.g. com.mycompany.obf . - digests Can be used to tell yGuard which digest algorithms should be used for the digest generation in the manifest file. Valid values are either none , or a comma-separated list of digest-algorithm identifiers, e.g. SHA-1, MD5 (which is the default). SHA-1, MD5 expose-attributes Can be used to give yGuard a list of attributes yGuard should expose in addition to the standard attributes. By default yGuard removes unneeded attributes like \"Deprecated\" from methods. The value can be a comma separated list of attributes as defined in Section 4.7 of the VM Specification of the .class File Format . E.g. in order to keep the \"Deprecated\" attribute one can add the following property: <property name=\"expose-attributes\" value=\"Deprecated\"/> Note that this affects all classes which will be obfuscated. For a better control of which attributes should be exposed in what classes use the Attribute Element . -","title":"Supported properties"},{"location":"task_documentation.html#child-elements_7","text":"The property element has no child elements.","title":"Child Elements"},{"location":"task_documentation.html#the-keep-element","text":"This element is a child of the rename or shrink element. It can be used to specify elements that are excluded from the parent rename or shrink task. The excluded classes, methods and fields are defined using nested package , class , method and field elements.","title":"The keep Element"},{"location":"task_documentation.html#attributes_7","text":"The keep element provides a number of boolean attributes that determine whether debug information and annotations present in the input class files are to be retained in the output files. The default behavior of the rename and shrink elements for the respective attributes is explained in the table below. Note that a more fine-grained control over which attributes to keep for which class files is possible using the attribute element. Also, the attribute element allows to define attributes to keep for both the rename and the shrink element in a common place. Attribute Description Default ( rename ) Default ( shrink ) sourcefile Determines whether the name of the original source code file should be included in the output class files. remove remove linenumbertable Determines whether the line number table, that contains a mapping from each opcode in the class file to the line number in the original source code file should be included in the output class files. remove remove localvariabletable Determines whether the local variable table, that contains a mapping from each local variable in the class file to the name that has been used in the original source code file should be included in the output class files. remove remove localvariabletypetable Determines whether the local variable type table, that contains a mapping from each local variable in the class file to the name and its generic type signature that has been used in the original source code file should be included in the output class files. remove remove runtimevisibleannotations Determines whether annotations with the retention policy RetentionPolicy.RUNTIME should be included in the output class files. keep 1 keep runtimevisibleparameterannotations Determines whether method paramater annotations with the retention policy RetentionPolicy.RUNTIME should be included in the output class files. keep 1 keep runtimevisibletypeannotations Determines whether type annotations with the retention policy RetentionPolicy.RUNTIME should be included in the output class files. keep 1 keep runtimeinvisibleannotations Determines whether annotations with the retention policy RetentionPolicy.CLASS should be included in the output class files. keep 1 remove runtimeinvisibleparameterannotations Determines whether method paramater annotations with the retention policy RetentionPolicy.CLASS should be included in the output class files. keep 1 remove runtimeinvisibletypeannotations Determines whether type annotations with the retention policy RetentionPolicy.CLASS should be included in the output class files. keep 1 remove 1 rename always keeps annotations irrespective of its runtime*annotations attribute values.","title":"Attributes"},{"location":"task_documentation.html#the-class-element","text":"The class element can be used for excluding certain classes and/or their fields and methods from the renaming or shrinking process. If no name , extends or implements attribute is given and the class element contains no nested patternset , a class element matches all class names. The classes , methods and fields attributes tell the shrinking and renaming engines which classes, methods and fields to keep based on their visibility. The following table lists the possible values for all of these attributes and shows which elements will be excluded. A '*' denotes, that elements that have the given visibility will be excluded for the specified attribute value. A '-' denotes that the these elements will not be excluded from the process. Value/Visibility public protected friendly private none - - - - public * - - - protected * * - - friendly * * * - private * * * *","title":"The class Element"},{"location":"task_documentation.html#attributes_8","text":"Attribute Description Required name The name of the class to be kept. No classes The visibility of the classes to be kept. No, defaults to none methods The visibility of the methods to be kept. No, defaults to none fields The visibility of the fields to be kept. No, defaults to none extends If no name attribute is given, keeps all classes that equal or extend the class defined by the given fully qualified classname. See serializable_example for an example usage of this attribute. No implements If no name attribute is given, keeps all classes that equal or implement the class defined by the given fully qualified classname. See serializable_example for an example usage of this attribute. No","title":"Attributes"},{"location":"task_documentation.html#child-elements_8","text":"patternset","title":"Child elements"},{"location":"task_documentation.html#explanation","text":"There are three possible ways of specifying which classes will be excluded from the shrinking and obfuscation process: 1) One can specify a single java class using the fully qualified name in java syntax with the name attribute. For example: <class name=\"mypackage.MyClass\"/> 2) One can specify multiple java classes using a modified version of a patternset. The patternset's includes and excludes element should use java syntax, but the usual wildcards are allowed. Some examples: <class> <patternset> <include name=\"com.mycompany.**.*Bean\"/> <exclude name=\"com.mycompany.secretpackage.*\"/> <exclude name=\"com.mycompany.myapp.SecretBean\"/> </patternset> </class> 3) This will expose all classes which reside in the package subtree of com.mycompany and whose name ends with Bean except for those, that reside in the com.mycompany.secretpackage package and the single SecretBean in com.mycompany.myapp . <class> <patternset> <include name=\"com.mycompany.myapp.MainClass\"/> <include name=\"org.w3c.sax?.\"/> <exclude name=\"org.w3c.sax?.**.*$$*\"/> </patternset> </class> This will expose the MainClass class and all classes, which reside in packages like org.w3c.sax1 , org.w3c.sax2 , org.w3c.saxb except for inner classes. '$' is used as a separator between outer class names and inner class names. Since Ant uses '$' as an escape character, you have to use two consecutive '$'s ( '$$' ) if you want to pass one as an argument to the task. 4) Finally one can specify classes depending on their visibility, i.e. depending whether they have been declared public , protected , package-private or private (inner classes). This can be achieved by additionally specifying the classes attribute in the class element. ```xml This will keep all class names, that are either `public` or `protected` and which reside in one of the subpackages of `com.mycompany.myapi` (note the abbreviation: the trailing dot behaves like the trailing `'/'` in the usual patternset, i.e. it could be rewritten as `com.mycompany.myapi.**.*`) ```xml <class classes=\"protected\" methods=\"protected\" fields=\"protected\"> <patternset> <include name=\"**.*\"/> </patternset> </class> This example shows the very common use case of excluding a complete public API from the shrinking and obfuscation process. There is an abbreviation for this use case: you can omit the patternset element, since in the case where the classes attribute is specified and there is no patternset child element used, the task will automatically apply this rule. In this example all classes will be exposed, that are either public or protected . Their methods and fields will be exposed as long as they are declared public or protected . If a class is package-private or private (inner classes), neither itself nor its methods or fields will be exposed. The last example shows how to keep the public methods of certain classes only, but neither field names nor the class names themselves. <class classes=\"none\" methods=\"public\" fields=\"none\"> <patternset> <include name=\"com.mycompany.myapi.\"/> </patternset> </class>","title":"Explanation"},{"location":"task_documentation.html#the-method-element","text":"Using the method element you can specify methods by signature which should be excluded from shrinking or name obfuscation.","title":"The method Element"},{"location":"task_documentation.html#attributes_9","text":"Attribute Description Required name Specifies the method to keep. Use the complete signature using fully qualified class names and the return type! Yes class Specifies the class which contains the method. Use the normal java syntax, i.e. the fully qualified name. This attribute can be omitted, if the patternset element is used as a child element, in which case all classes matching the patternset will be searched and their corresponding methods will be kept. No","title":"Attributes"},{"location":"task_documentation.html#child-elements_9","text":"patternset","title":"Child Elements"},{"location":"task_documentation.html#examples_1","text":"<method class=\"com.mycompany.myapp.MyClass\" name=\"void main(java.lang.String[])\"/> <method class=\"com.mycompany.myapp.MyClass\" name=\"int foo(double[][], java.lang.Object)\"/> <method name=\"void writeObject(java.io.ObjectOutputStream)\"> <patternset> <include name=\"com.mycompany.myapp.data.*\"/> </patternset> </method> <method name=\"void readObject(java.io.ObjectInputStream)\"> <patternset> <include name=\"com.mycompany.myapp.data.*\"/> </patternset> </method> This will keep the main method of the MyClass class and the foo method. Additionally all readObject and writeObject methods (used for serialization) will be kept in all classes of the com.mycompany.myapp.data package. Note that you have to specify the return argument's type, even if it is void and that you have to use the fully qualified name for all classes, even those, that are in the java.lang package .","title":"Examples"},{"location":"task_documentation.html#the-field-element","text":"Using the field element you can specify fields by name which should be excluded from shrinking or name obfuscation.","title":"The field Element"},{"location":"task_documentation.html#attributes_10","text":"Attribute Description Required name Specifies the field to keep. Use the name of the field only, do not include its type! Yes class Specifies the class which contains the field. Use the normal java syntax, i.e. the fully qualified name. This attribute can be omitted, if the patternset element is used as a child element, in which case the all classes matching the patternset will be searched and their corresponding fields will be kept. No","title":"Attributes"},{"location":"task_documentation.html#child-elements_10","text":"patternset","title":"Child Elements"},{"location":"task_documentation.html#examples_2","text":"<field class=\"com.mycompany.myapp.MyClass\" name=\"field\"/> <field name=\"serialVersionUID\"> <patternset> <include name=\"com.mycompany.myapp.data.*\"/> </patternset> </field> This will keep the field named field of the MyClass class. Additionally all the serialVersionUID fields (used for serialization) will be kept in all classes of the com.mycompany.myapp.data package.","title":"Examples"},{"location":"task_documentation.html#the-package-element","text":"The package element can be used for excluding certain package's names from the renaming process. It cannot be used for the shrinking process. All packages that are matched be the nested patternset element will not be obfuscated. This has no influence on the class, method, or field names but will only result in the package's name not being obfuscated. Normally, it is not necessary to use this element, instead the class element is used to keep class names (and thus their package names) from being obfuscated.","title":"The package Element"},{"location":"task_documentation.html#child-elements_11","text":"patternset","title":"Child Elements"},{"location":"task_documentation.html#example_2","text":"<package> <patternset> <include name=\"com.mycompany.myapp.*\"/> </patternset> </package> This will keep the names of all packages that are direct descendants of com.mycompany.myapp . This will not influence the names of the classes contained in these packages.","title":"Example"},{"location":"task_documentation.html#the-sourcefile-element","text":"The sourcefile element allows for a special treatment of the sourceFile attribute by the rename element. Using nested property elements, the mapping of sourceFile attributes in obfuscated class files can be adjusted.","title":"The sourcefile Element"},{"location":"task_documentation.html#attributes_11","text":"Name Description mapping The value of this property determines the name all sourceFile attributes matched by the sourcefile element are mapped to.","title":"Attributes"},{"location":"task_documentation.html#child-elements_12","text":"property patternset","title":"Child Elements"},{"location":"task_documentation.html#example_3","text":"<sourcefile> <property name=\"mapping\" value=\"y\"/> <patternset> <include name=\"com.mycompany.myapp.**\"/> </patternset> </sourcefile> This will map all of the sourceFile attributes in the packages below com.mycompany.myapp to \"y\" , which is small and generally a nice letter.","title":"Example"},{"location":"task_documentation.html#the-linenumbertable-element","text":"The linenumbertable element allows for a special treatment of the linenumbertable attribute by the rename element. Using nested property elements, the mapping of linenumbertable attributes in obfuscated class files can be adjusted.","title":"The linenumbertable Element"},{"location":"task_documentation.html#attributes_12","text":"Name Description mapping-scheme Can be used with the following two values: scramble This will use a non-trivial algorithm to scramble the line numbers in the existing file. The algorithm implemented uses a different scrambling scheme for each class. The optional scrambling-salt property can be used to provide an integer value that will be used to \"salt\" the algorithm's random seed for the scrambling. The size of the (uncompressed) .class file will not change using this mapping scheme. squeeze This will use a simple algorithm that virtually puts all of a method's code into the first line of code of the method. It will appear as if each method had been written in a single line of code. The advantage of this scheme is drastically reduced size requirements and thus smaller .class files, while at the same time it will be possible to unambiguously determine the exact method from a stacktrace. scrambling-salt Can be used in conjunction with mapping-scheme to provide an integer value that will be used to \"salt\" the algorithm's random seed for the scrambling.","title":"Attributes"},{"location":"task_documentation.html#child-elements_13","text":"property patternset","title":"Child Elements"},{"location":"task_documentation.html#examples_3","text":"<linenumbertable> <patternset> <include name=\"com.mycompany.myapp.**\"/> </patternset> </linenumbertable> This will keep the line numbers of all the classes in the com.mycompany.myapp packages and subpackages. Note that in order to see the line numbers in stacktraces, the sourcefile attribute has to be retained for those files, too, since otherwise the JDK will display \"Unknown source\" for the stack elements. <linenumbertable> <property name=\"mapping-scheme\" value=\"scramble\"/> <property name=\"scrambling-salt\" value=\"1234\"/> <patternset id=\"CompanyPatternSet\"> <include name=\"com.mycompany.myapp.**\"/> </patternset> </linenumbertable> <sourcefile> <property name=\"mapping\" value=\"y\"/> <patternset refid=\"CompanyPatternSet\"/> </sourcefile> This will keep scrambled line numbers for all classes found in and below the com.mycompany.myapp packages. The scrambling algorithm will use the given \"salt\" value to use a predefined scrambling scheme. In order to see the scrambled line numbers, a sourcefile element is used on the same patternset, which is referenced by its previously declared reference id, to rename the source files to \"y\" .","title":"Examples"},{"location":"task_documentation.html#the-adjust-element","text":"Using the adjust element one can specify resource files whose names and/or contents should be adjusted by the rename engine to reflect the obfuscated class names. Note : This will only adjust files that are part of the inoutpair jars! I.e. the fileset's root directory is the combined root of all jars that are passed to yGuard via the inoutpair elements. yGuard will not modify any of the files on disk, except for the out-jar!","title":"The adjust Element"},{"location":"task_documentation.html#attributes_13","text":"Attribute Description Required replaceContentPolicy Specifies if and how the content of resource files should be adjusted. See replaceContentPolicy for supported values. No, defaults to none replaceContent Deprecated - use replaceContentPolicy instead. Specifies whether or not the contents of resource files should be adjusted. No, defaults to false replaceContentSeparator Specifies which separator is used to replace text in content. Supports . , / , and ./ . No, defaults to / replacePathPolicy Specifies if and how the file names of resource files should be adjusted. See replacePathPolicy for supported values. No, defaults to path replacePath Deprecated - use replacePathPolicy instead. Specifies whether or not the paths to the resource files should be adjusted. No, defaults to true replaceName Deprecated - use replacePathPolicy instead. Specifies whether or not the names of the specified resources should be adjusted. No, defaults to false","title":"Attributes"},{"location":"task_documentation.html#the-replacecontentpolicy-attribute","text":"Specifies if and how the content of resource files should be adjusted. Supported values are: none The content of resource files is not adjusted. lenient Text that is recognized as qualifed class or package name is replaced. This policy matches the yGuard 3.x behavior for replaceContent=\"true\" strict Text that is recognized as qualifed class name is replaced. This policy matches the yGuard 2.x behavior for replaceContent=\"true\"","title":"The replaceContentPolicy Attribute"},{"location":"task_documentation.html#the-replacepathpolicy-attribute","text":"Specifies if and how the file names of resource files should be adjusted. Supported values are: none The paths to and names of resource files are not adjusted. The names of service provider configuration files are not adjusted. This policy matches the yGuard 3.x behavior for replaceName=\"false\" replacePath=\"false\" path The paths to resource files are adjusted, if they match the package name of a renamed package. The names of resource files are not adjusted. The names of service provider configuration files are not adjusted. This policy matches the yGuard 3.x behavior for replaceName=\"false\" replacePath=\"true\" name The paths to resource files are not adjusted. The names of resource files are adjusted, if the path to and the name of the resource file match the qualified name of a renamed class. The names of service provider configuration files are adjusted, if the name of the configuration file matches the qualified name of a renamed class. This policy matches the yGuard 3.x behavior for replaceName=\"true\" replacePath=\"false\" file The paths to and names of resource files are adjusted, if they match the qualified name of a renamed class. The names of service provider configuration files are adjusted, if the name of the configuration file matches the qualified name of a renamed class. This policy matches the yGuard 3.x behavior for replaceName=\"true\" replacePath=\"true\" fileorpath Combines policies file and path . I.e. if the path to and name of a resource file match the qualified name of a renamed class, both path and name are adjusted accordingly. If the path and name do not match the qualified name of a renamed class, but the path matches the package name of a renamed package, the path is adjusted accordingly. If the path does not match the package name of a renamed package, but path fragments match the package name of a renamed package, those path fragments are adjusted accordingly. The names of service provider configuration files are adjusted, if the name of the configuration file matches the qualified name of a renamed class. lenient Tries to adjust as much of the paths to and names of resource and service provider configuration files as possible. For paths to and names of resource files, this policy is the same as fileorpath . The names of service provider configuration files are adjusted, if the name of the configuration file matches the qualified name of a renamed class. If the name does not match the qualified name of a renamed class, but name fragments match the package name of a renamed package, those name fragments are adjusted accordingly.","title":"The replacePathPolicy Attribute"},{"location":"task_documentation.html#explanation_1","text":"Suppose yGuard's input set consists of the following files com/mycompany/myproduct/MyClass.class com/mycompany/myproduct/MyClass.properties com/mycompany/myproduct/SomeResource.txt com/mycompany/shared/SharedResource.txt META-INF/services/com.mycompany.myproduct.MyClass META-INF/services/com.mycompany.shared.SharedService and rename changes the name of class com.mycompany.myproduct.MyClass to A.A.A.A . In this case, the individual replacePathPolicy polices will result in the following path and name adjustments: path A/A/A/MyClass.properties A/A/A/SomeResource.txt A/A/shared/SharedResource.txt META-INF/services/com.mycompany.myproduct.MyClass META-INF/services/com.mycompany.shared.SharedService The path com/mycompany/shared does not match any package name, but its path fragments com/mycompany match the package name com.mycompany and thus are changed. The two service provider configuration files are not adjusted. name com/mycompany/myproduct/A.properties com/mycompany/myproduct/SomeResource.txt com/mycompany/shared/SharedResource.txt META-INF/services/A.A.A.A META-INF/services/com.mycompany.shared.SharedService The path to and name of the second and third resource files do not match any qualified class name in the code base and thus are not changed. The name com.mycompany.shared.SharedService does not match any qualified class name and thus is not changed. file A/A/A/A.properties com/mycompany/myproduct/SomeResource.txt com/mycompany/shared/SharedResource.txt META-INF/services/A.A.A.A META-INF/services/com.mycompany.shared.SharedService The path to and name of the second and third resource files do not match any qualified class name in the code base and thus are not changed. The name com.mycompany.shared.SharedService does not match any qualified class name and thus is not changed. fileorpath A/A/A/A.properties A/A/A/SomeResource.txt A/A/shared/SharedResource.txt META-INF/services/A.A.A.A META-INF/services/com.mycompany.shared.SharedService The path com/mycompany/shared does not match any package name, but its path fragments com/mycompany match the package name com.mycompany and thus are changed. The name com.mycompany.shared.SharedService does not match any qualified class name and thus is not changed. lenient A/A/A/A.properties A/A/A/SomeResource.txt A/A/shared/SharedResource.txt META-INF/services/A.A.A.A META-INF/services/A.A.shared.SharedService The path com/mycompany/shared does not match any package name, but its path fragments com/mycompany match the package name com.mycompany and thus are changed. The name com.mycompany.shared.SharedService does not match any qualified class name, but its name fragments com.mycompany match the package name com.mycompany and thus are changed.","title":"Explanation"},{"location":"task_documentation.html#child-elements_14","text":"The adjust element can be used just like the standard Ant ZipFileSet element.","title":"Child Elements"},{"location":"task_documentation.html#examples_4","text":"<!-- adjust the names of all java property files in the jars --> <adjust replacePathPolicy=\"file\"> <include name=\"**/*.properties\"/> </adjust> <!-- adjust the classnames specified within a single XML file in the jar --> <adjust file=\"plugins.xml\" replaceContentPolicy=\"strict\" replaceContentSeparator=\".\"/> <!-- suppress the adjustment of the resource path com/mycompany/myapp/resource in the jar. --> <!-- the package com.mycompany.myapp still gets obfuscated. --> <adjust replacePathPolicy=\"none\"> <include name=\"com/mycompany/myapp/resource/*\"/> </adjust>","title":"Examples"},{"location":"task_documentation.html#the-map-element","text":"The map element is an immediate optional child of the rename element . It can be used to specify the mapping for the renaming process directly. This is an advanced topic.","title":"The map Element"},{"location":"task_documentation.html#child-elements_15","text":"package class method field All of these elements use the name attribute to specify the specific element. The method and field elements need the class attribute in order to function properly. Neither wildcards nor nested patternset elements are allowed. Use the map attribute to specify the new name (subpackage, classname, methodname and fieldname respectively).","title":"Child Elements"},{"location":"task_documentation.html#examples_5","text":"<map> <package name=\"com\" map=\"etc\"/> <package name=\"com.mycompany\" map=\"nocompany\"/> <package name=\"com.mycompany.myapp\" map=\"asdf\"/> <class name=\"com.mycompany.myapp.MainApp\" map=\"foo\"/> <method class=\"com.mycompany.myapp.MainApp\" name=\"void main(java.lang.String[])\" map=\"bar\"/> <field class=\"com.mycompany.myapp.MainApp\" name=\"field\" map=\"a\"/> </map> In this example the package structure com.mycompany.myapp will be obfuscated to etc.nocompany.asdf . The MainApp class will be called foo and its main method will be remapped to bar (and can therefor not be executed from commandline anymore). The field called field will be renamed to a .","title":"Examples"},{"location":"task_documentation.html#controlling-obfuscation-exclusion-with-annotations","text":"In order to exclude certain elements from obfuscation, it is possible to use annotations in the source code instead of listing those elements in the keep element . Any annotation class can be used for this, but it must be specified in the annotationClass attribute of the rename element and follow the convention as explained below to work. yGuard contains such an annotation in the distribution package ready for use. The annotation class is com.yworks.util.annotation.Obfuscation and can be found in the yGuard distribution in ObfuscationAnnotation.jar . Feel free add this attribute definition to your own codebase and possibly adjust the package name to your needs. Here is the source code for it:","title":"Controlling obfuscation exclusion with annotations"},{"location":"task_documentation.html#obfuscationjava","text":"package com.yworks.util.annotation; public @interface Obfuscation { boolean exclude() default true; boolean applyToMembers() default true; } This class is also the default annotation yGuard is looking for when obfuscating. By default the Obfuscation annotation is inherited using the @Inherited trait. If this behaviour is undesirable, consider creating a custom obfuscation annotation. The convention for annotation classes that yGuard understands as obfuscation controlling annotations requires two attributes: Attribute Description Default value exclude Specifies whether the annotated element should be excluded from the obfuscation. Note, that when retaining a class, the hierarchy of that class, i.e. the chain of outer class names and the package name, is also retained. true applyToMembers Specifies whether the child elements of the annotated element, if not otherwise specified, should be excluded from the obfuscation. For example, when annotating a class with exclude = true and this attribute set to true , inner classes, fields and methods of this class will be excluded from obfuscation. Annotating a child element of an element that has this attribute set to true will override the parents annotation configuration. true","title":"Obfuscation.java"},{"location":"task_documentation.html#generating-patch-jars","text":"The true power of the map element lies in its use together with the patch element, which itself is a child element of the rename top level element.","title":"Generating Patch JARs"},{"location":"task_documentation.html#attributes_14","text":"The patch element has no attributes.","title":"Attributes"},{"location":"task_documentation.html#child-elements_16","text":"class","title":"Child Elements"},{"location":"task_documentation.html#examples_6","text":"Using the patch element one can generate jars, that can be used to serve as patches for versions of an application that have already been deployed in obfuscated form. During the main obfuscation run, yGuard produces an xml-logfile, in which the mapping between the unobfuscated and obfuscated names is contained. The patch element is used to declare a set of classes, that need to be patched. During the obfuscation, yGuard will include those files in the obfuscated jars only, that are declared inside this element. <patch> <class name=\"com.mycompany.myapp.MainClass\"/> <class> <patternset> <include name=\"com.mycompany.myapp.bugs.*\"/> </patternset> </class> </patch> <map logfile=\"yguardlog.xml\"/> This will only include the MainClass class and all classes that belong to the bugs package in a patch jar. In order to work with the previously delivered obfuscated version, it is important to use the map element to specify the mapping of the elements from the previous run. This can most conveniently be achieved by specifying the log file from the corresponding run in the map element's logfile attribute.","title":"Examples"},{"location":"task_documentation.html#deobfuscating-stacktraces","text":"yGuard provides a simple tool that makes it easy for the obfuscating party to deobfuscate stacktraces which have been obfuscated using yGuard. During the obfuscation yGuard produces an xml logfile which can automatically be gzipped for convenient storage. You should always keep those logfiles in order to be able to deobfuscate fully qualified classnames or methods or fields for debugging purposes e.g. In order to run the yGuard deobfuscation tool do the following: Console> java -jar yguard.jar mylogfile.xml A tiny GUI will popup that will enable you to easily deobfuscate stacktraces and fully qualified classnames as well as provide a convenient way to browse the mapping generated by yGuard. In the main window a tree view displays the package, class, and classmember hierarchy using the unobfuscated names. For each entry that has been obfuscated (classes, packages, methods, and fields that have not been obfuscated at all may not always be shown in the tree) the corresponding mapped/obfuscated name is displayed. The two buttons at the top of the window allow to change the sorting of the items in the tree structure, so that they are either sorted according to their names before or after the obfuscation. Items will always be sorted by type first: packages, classes, innerclasses, methods, and fields. Small icons provide a convenient way to quickly find the corresponding items. The lower part of the window contains an editable text area that can be used to enter text or paste stacktraces in. Pressing the button at the bottom of the window labelled \"Deobfuscate\" will trigger the deobfuscation of the contents in the text area. The tool will try to identify fully qualified class names (separated by dots) and use the mapping information to reconstruct the original names. If the tool identifies a stack trace element, it will try to deobfuscate scrambled line numbers, too, if they have been scrambled during the obfuscation process.","title":"Deobfuscating stacktraces"},{"location":"task_documentation.html#dtd-used-for-ant-yguard","text":"The obfuscation and shrinking process can be completely configured inside your Ant script. The yguard task and nested elements should be used according to the following DTD. Note that this is for information purposes only, i.e. you do not have to include the following lines anywhere. This DTD should just provide a quick overview of the yGuard syntax. Due to restrictions of the DTD specification, the given DTD does not describe all available yGuard options. Please browse through the documentation above for complete documentation of the yGuard Ant task elements. <!ELEMENT yguard (inoutpair+,externalclasses?,attribute*,(shrink|rename)+)> <!ELEMENT inoutpair EMPTY> <!ATTLIST inoutpair in CDATA #REQUIRED out CDATA #REQUIRED resources CDATA #IMPLIED> <!-- NOTE: the resources attribute only has an effect if a shrink element is present inside the yguard element. --> <!ELEMENT externalclasses ANY> <!-- the externalclasses element is used just like Ant's classpath element. See the Ant documentation for further details--> <!ELEMENT attribute (patternset)*> name CDATA #REQUIRED> <!ELEMENT shrink (entrypointjar*,keep?)> <!ATTLIST shrink logfile CDATA #IMPLIED createStubs CDATA #IMPLIED> <!ELEMENT entrypointjar> <!ATTLIST entrypointjar name CDATA #REQUIRED> <!ELEMENT rename (property*,patch?,adjust*,map?,keep?)> <!ATTLIST rename mainclass CDATA #IMPLIED logfile CDATA #IMPLIED conservemanifest CDATA #IMPLIED replaceClassNameStrings CDATA #IMPLIED> <!ELEMENT property EMPTY> <!ATTLIST property name CDATA #REQUIRED value CDATA #REQUIRED> <!ELEMENT patch (class)*> <!ELEMENT adjust (#PCDATA)> <!ATTLIST adjust replaceName CDATA #REQUIRED replaceContent CDATA #REQUIRED replacePath CDATA #REQUIRED> <!ELEMENT map (class|method|field|package)*> <!ELEMENT package (patternset)*> <!ATTLIST package name CDATA #REQUIRED map CDATA #REQUIRED> <!-- NOTE: the map attribute is only supported if the <package> element is nested inside a <map> element, whereas the patternset is only supported inside the <keep>/<expose> sections. --> <!ELEMENT keep (package|class|method|field|sourcefile|linenumbertable)*> <!-- NOTE: the nested <package>,<sourcefile>,<linenumbertable> and <attribute> sections are only supported in the <rename> element. --> <!ATTLIST keep linenumbertable CDATA #IMPLIED localvariabletable CDATA #IMPLIED localvariabletypetable CDATA #IMPLIED runtimeinvisibleannotations CDATA #IMPLIED runtimeinvisibletypeannotations CDATA #IMPLIED runtimevisibleannotations CDATA #IMPLIED runtimevisibletypeannotations CDATA #IMPLIED sourcefile CDATA #IMPLIED> <!ELEMENT class (patternset)*> <!ATTLIST class classes CDATA #IMPLIED fields CDATA #IMPLIED map CDATA #IMPLIED methods CDATA #IMPLIED name CDATA #IMPLIED> <!-- NOTE: the map attribute is only supported if the <class> element is nested inside an <rename> element. --> <!ELEMENT method (patternset)*> <!ATTLIST method class CDATA #IMPLIED map CDATA #IMPLIED name CDATA #IMPLIED> <!-- NOTE: the map attribute is only supported if the <method> element is nested inside an <rename> element. --> <!ELEMENT field (patternset)*> <!ATTLIST field class CDATA #IMPLIED map CDATA #IMPLIED name CDATA #IMPLIED> <!-- NOTE: the field attribute is only supported if the <method> element is nested inside an <rename> element. --> Attention users of IDEs that \"support\" the creation of Ant files (e.g. IDEA's IntelliJ): Your IDE may indicate some errors inside your ANT file when you use yGuard specific elements. This is because the IDE does not know about the DTD used by yGuard. However this is not a real problem, since the Ant file should nevertheless work as expected.","title":"DTD used for Ant &lt;yguard&gt;"},{"location":"troubleshooting.html","text":"Troubleshooting There are a couple of things you should be aware of when obfuscating and shrinking software. The weakest part of an application considering name obfuscation and code shrinking is code that uses reflection to dynamically load classes, invoke methods etc. Therefore, you have to be especially careful when using the yguard task on applications that rely on reflection. The most important facts to keep in mind when using yGuard are described here briefly: If you use the rename task, code in the form of MyApplication.class will break if MyApplication will be obfuscated by name and the obfuscation switch replaceClassNameStrings is set to false . The shrink task will currently recognize code in the form of MyApplication.class only if the java files were compiled using an arbitrary version of the standard javac compiler (although the shrinking engine might recognize the .class construct also if the classes were compiled using a compiler that generates similar bytecode). Automatic introspection and reflection will break in most cases, when you decide to obfuscate the corresponding methods and fields. If you use the shrink task and your application uses reflection you should explicitly designate all entities loaded per reflection as code entrypoints using the keep element. If your application is broken after using the shrink task, consider using the createStubs attribute of the shrink task to find out which additional entities you need to include in the keep element. Class.forName(className) will not work when using the rename task unless you use the obfuscated name string in your variable or the String is a local constant and replaceClassNameStrings is not set or set to true . If you use the shrink task, className should be contained in the list of entrypoints using the keep element. The customized serialization mechanism will not work if you obfuscated or shrinked the writeObject and readObject methods as well as the serializationUID field. Simple bean introspection will not work, if you decide to obfuscate your public accessor methods, since it makes use of reflection. If you do not set the -Xmx property for the Java virtual machine, the yguard Ant task might fail due to a java.lang.OutOfMemoryError . To solve this problem, set the -Xmx option in the ANT_OPTS variable, e.g.: bash> export ANT_OPTS=\"-Xmx512M\" or cshell> setenv ANT_OPTS \"-Xmx512M\"","title":"Troubleshooting"},{"location":"troubleshooting.html#troubleshooting","text":"There are a couple of things you should be aware of when obfuscating and shrinking software. The weakest part of an application considering name obfuscation and code shrinking is code that uses reflection to dynamically load classes, invoke methods etc. Therefore, you have to be especially careful when using the yguard task on applications that rely on reflection. The most important facts to keep in mind when using yGuard are described here briefly: If you use the rename task, code in the form of MyApplication.class will break if MyApplication will be obfuscated by name and the obfuscation switch replaceClassNameStrings is set to false . The shrink task will currently recognize code in the form of MyApplication.class only if the java files were compiled using an arbitrary version of the standard javac compiler (although the shrinking engine might recognize the .class construct also if the classes were compiled using a compiler that generates similar bytecode). Automatic introspection and reflection will break in most cases, when you decide to obfuscate the corresponding methods and fields. If you use the shrink task and your application uses reflection you should explicitly designate all entities loaded per reflection as code entrypoints using the keep element. If your application is broken after using the shrink task, consider using the createStubs attribute of the shrink task to find out which additional entities you need to include in the keep element. Class.forName(className) will not work when using the rename task unless you use the obfuscated name string in your variable or the String is a local constant and replaceClassNameStrings is not set or set to true . If you use the shrink task, className should be contained in the list of entrypoints using the keep element. The customized serialization mechanism will not work if you obfuscated or shrinked the writeObject and readObject methods as well as the serializationUID field. Simple bean introspection will not work, if you decide to obfuscate your public accessor methods, since it makes use of reflection. If you do not set the -Xmx property for the Java virtual machine, the yguard Ant task might fail due to a java.lang.OutOfMemoryError . To solve this problem, set the -Xmx option in the ANT_OPTS variable, e.g.: bash> export ANT_OPTS=\"-Xmx512M\" or cshell> setenv ANT_OPTS \"-Xmx512M\"","title":"Troubleshooting"}]}